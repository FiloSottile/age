package passphrase

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"golang.org/x/crypto/ssh/terminal"
)

// PromptForEncryption prompts interactively and returns user-entered passphrase upon confirmation
// (or an autogenerated passphrase if leave empty).
func PromptForEncryption() ([]byte, error) {
	fmt.Fprintf(os.Stderr, "Enter passphrase (leave empty to autogenerate a secure one): ")
	pass, err := readPassphrase()
	if err != nil {
		return nil, fmt.Errorf("could not read passphrase: %v", err)
	}
	p := string(pass)
	if p == "" {
		var words []string
		for i := 0; i < 10; i++ {
			words = append(words, randomWord())
		}
		p = strings.Join(words, "-")
		fmt.Fprintf(os.Stderr, "Using the autogenerated passphrase %q.\n", p)
	} else {
		fmt.Fprintf(os.Stderr, "Confirm passphrase: ")
		confirm, err := readPassphrase()
		if err != nil {
			return nil, fmt.Errorf("could not read passphrase: %v", err)
		}
		if string(confirm) != p {
			return nil, fmt.Errorf("passphrases didn't match")
		}
	}
	return []byte(p), nil
}

// PromptForDecryption returns interactively user-entered passphrase from stdin.
func PromptForDecryption() ([]byte, error) {
	fmt.Fprintf(os.Stderr, "Enter passphrase: ")
	pass, err := readPassphrase()
	if err != nil {
		return nil, fmt.Errorf("could not read passphrase: %v", err)
	}
	return pass, nil
}

func readPassphrase() ([]byte, error) {
	fd := int(os.Stdin.Fd())
	// FIXME: not so sure how this stdinInUse check work, or whether we can delete it
	if name := flag.Arg(0); name == "" || name == "-" || !terminal.IsTerminal(fd) {
		tty, err := os.Open("/dev/tty")
		if err != nil {
			return nil, fmt.Errorf("standard input is not available or not a terminal, and opening /dev/tty failed: %v", err)
		}
		defer tty.Close()
		fd = int(tty.Fd())
	}
	defer fmt.Fprintf(os.Stderr, "\n")
	p, err := terminal.ReadPassword(fd)
	if err != nil {
		return nil, err
	}
	return p, nil
}
